<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perceptual Mapping Analysis Tool</title>
    <!-- GitHub Pages deployment -->
    
    <!-- External libraries -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 30px; 
            border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.15); 
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.2em;
        }
        .step { 
            margin-bottom: 30px; 
            padding: 25px; 
            border: 2px solid #e8ecf0; 
            border-radius: 12px; 
            background: #fafbfc;
            transition: all 0.3s ease;
        }
        .step.active { 
            border-color: #4CAF50; 
            background: #f8fff8;
        }
        .step.completed { 
            border-color: #4CAF50; 
            background: #f0f8f0; 
        }
        .step-header { 
            font-size: 1.4em; 
            font-weight: 600; 
            margin-bottom: 15px; 
            color: #333; 
        }
        .file-drop { 
            border: 3px dashed #ddd; 
            border-radius: 12px; 
            padding: 40px 20px; 
            text-align: center; 
            color: #666; 
            margin: 15px 0;
            background: white;
            transition: all 0.3s ease;
        }
        .file-drop.dragover { 
            border-color: #4CAF50; 
            background: #f8fff8; 
            color: #4CAF50;
        }
        .file-drop:hover {
            border-color: #999;
            background: #f9f9f9;
        }
        textarea { 
            width: calc(100% - 22px); 
            min-height: 200px; 
            padding: 15px; 
            border: 2px solid #e8ecf0; 
            border-radius: 8px; 
            font-family: 'Monaco', 'Menlo', monospace; 
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
        }
        input[type="text"], select { 
            width: calc(100% - 22px); 
            padding: 12px 15px; 
            border: 2px solid #e8ecf0; 
            border-radius: 8px; 
            margin: 8px 0; 
            font-size: 16px;
        }
        button { 
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); 
            color: white; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 10px 5px 10px 0;
        }
        button:hover { 
            background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        button:disabled { 
            background: #e0e0e0; 
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pending { background-color: #ffc107; }
        .status-active { background-color: #2196f3; animation: pulse 2s infinite; }
        .status-completed { background-color: #4caf50; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }
        
        .analysis-summary { 
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); 
            padding: 20px; 
            border-radius: 12px; 
            margin: 15px 0;
            border-left: 5px solid #2196f3;
        }
        .hidden { display: none; }
        .data-preview {
            max-height: 300px;
            overflow: auto;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .dimensions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .map-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        #plotly-div {
            width: 100%;
            height: 600px;
        }
        .info-box {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #155724;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Perceptual Mapping Analyzer</h1>
        <p class="subtitle">Upload survey data to generate interactive perceptual maps and competitive analysis</p>
        
        <!-- Step 1: Survey Data Upload -->
        <div class="step active" id="step1">
            <div class="step-header">
                <span class="status-indicator status-active"></span>
                üìä Step 1: Survey Data Upload
            </div>
            <p><strong>Requirements:</strong> CSV file with survey responses (30+ respondents, rating scale 1-9)</p>
            
            <div class="file-drop" id="survey-drop">
                <div style="font-size: 48px; margin-bottom: 15px;">üìä</div>
                <p><strong>Drag & drop your CSV file here</strong></p>
                <p style="margin: 10px 0;">or</p>
                <input type="file" id="survey-file" accept=".csv" style="display: none;">
                <button onclick="document.getElementById('survey-file').click()">Browse Files</button>
            </div>
            
            <div id="data-preview" class="data-preview hidden"></div>
            <div id="data-summary" class="analysis-summary hidden"></div>
        </div>
        
        <!-- Step 2: Map Configuration -->
        <div class="step" id="step2">
            <div class="step-header">
                <span class="status-indicator status-pending"></span>
                ‚öôÔ∏è Step 2: Configure Perceptual Map
            </div>
            
            <div class="dimensions-grid">
                <div>
                    <label for="x-dimension"><strong>X-Axis Dimension:</strong></label>
                    <select id="x-dimension">
                        <option value="">Select dimension...</option>
                    </select>
                </div>
                <div>
                    <label for="y-dimension"><strong>Y-Axis Dimension:</strong></label>
                    <select id="y-dimension">
                        <option value="">Select dimension...</option>
                    </select>
                </div>
            </div>
            
            <div class="info-box">
                <strong>üí° Tip:</strong> Choose dimensions that represent different competitive aspects (e.g., Price vs Quality, Innovation vs Reliability)
            </div>
            
            <button id="generate-map-btn" disabled>Generate Perceptual Map</button>
        </div>
        
        <!-- Step 3: Results -->
        <div class="step" id="step3">
            <div class="step-header">
                <span class="status-indicator status-pending"></span>
                üìà Step 3: Interactive Perceptual Map
            </div>
            
            <div id="map-container" class="map-container hidden">
                <div id="plotly-div"></div>
                <div class="info-box">
                    <strong>üéØ How to read this map:</strong>
                    <ul>
                        <li><strong>Position:</strong> Each product's average score on the selected dimensions</li>
                        <li><strong>Bubble size:</strong> Number of survey responses for that product</li>
                        <li><strong>Quadrants:</strong> Different competitive positions based on the chosen dimensions</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let surveyData = null;
        let processedData = null;

        // File upload handling
        function setupFileUpload() {
            const dropZone = document.getElementById('survey-drop');
            const fileInput = document.getElementById('survey-file');
            
            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        }

        function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            Papa.parse(file, {
                header: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        alert('Error parsing CSV: ' + results.errors[0].message);
                        return;
                    }
                    
                    surveyData = results.data.filter(row => {
                        return Object.values(row).some(val => val && val.toString().trim() !== '');
                    });
                    
                    displayDataPreview();
                    analyzeData();
                    updateStepStatus('step1', 'completed');
                    updateStepStatus('step2', 'active');
                }
            });
        }

        function displayDataPreview() {
            const preview = document.getElementById('data-preview');
            const sample = surveyData.slice(0, 5);
            
            let html = '<h4>Data Preview (first 5 rows):</h4><table border="1" style="width: 100%; font-size: 11px;">';
            
            // Header
            html += '<tr>';
            Object.keys(sample[0]).forEach(key => {
                html += `<th style="padding: 5px; background: #f0f0f0;">${key}</th>`;
            });
            html += '</tr>';
            
            // Data rows
            sample.forEach(row => {
                html += '<tr>';
                Object.values(row).forEach(val => {
                    html += `<td style="padding: 5px;">${val}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</table>';
            preview.innerHTML = html;
            preview.classList.remove('hidden');
        }

        function analyzeData() {
            if (!surveyData || surveyData.length === 0) return;

            // Find identifier column (product names)
            const columns = Object.keys(surveyData[0]);
            let identifierColumn = null;
            
            // Look for columns that might contain product names
            const identifierKeywords = ['phone', 'product', 'brand', 'model', 'device', 'name', 'item'];
            for (const col of columns) {
                if (identifierKeywords.some(keyword => col.toLowerCase().includes(keyword))) {
                    identifierColumn = col;
                    break;
                }
            }
            
            if (!identifierColumn) {
                identifierColumn = columns[0]; // Use first column as fallback
            }

            // Find rating columns (numeric columns that aren't the identifier)
            const ratingColumns = columns.filter(col => {
                if (col === identifierColumn) return false;
                
                // Check if column contains numeric data
                const sampleValues = surveyData.slice(0, 10).map(row => row[col]);
                const numericValues = sampleValues.filter(val => !isNaN(parseFloat(val)) && isFinite(val));
                return numericValues.length > sampleValues.length * 0.7; // At least 70% numeric
            });

            processedData = {
                identifierColumn: identifierColumn,
                ratingColumns: ratingColumns,
                data: surveyData
            };

            // Populate dimension selectors
            const xSelect = document.getElementById('x-dimension');
            const ySelect = document.getElementById('y-dimension');
            
            xSelect.innerHTML = '<option value="">Select dimension...</option>';
            ySelect.innerHTML = '<option value="">Select dimension...</option>';
            
            ratingColumns.forEach(col => {
                const option1 = new Option(col.replace(/_/g, ' '), col);
                const option2 = new Option(col.replace(/_/g, ' '), col);
                xSelect.appendChild(option1);
                ySelect.appendChild(option2);
            });

            // Display analysis summary
            const summary = document.getElementById('data-summary');
            summary.innerHTML = `
                <h4>üìä Data Analysis Summary:</h4>
                <p><strong>Total Responses:</strong> ${surveyData.length.toLocaleString()}</p>
                <p><strong>Product Column:</strong> ${identifierColumn}</p>
                <p><strong>Rating Dimensions:</strong> ${ratingColumns.length} (${ratingColumns.join(', ')})</p>
                <p><strong>Unique Products:</strong> ${[...new Set(surveyData.map(row => row[identifierColumn]))].length}</p>
            `;
            summary.classList.remove('hidden');

            // Enable map generation when both dimensions are selected
            function checkDimensions() {
                const xDim = document.getElementById('x-dimension').value;
                const yDim = document.getElementById('y-dimension').value;
                document.getElementById('generate-map-btn').disabled = !xDim || !yDim || xDim === yDim;
            }

            document.getElementById('x-dimension').addEventListener('change', checkDimensions);
            document.getElementById('y-dimension').addEventListener('change', checkDimensions);
        }

        function generatePerceptualMap() {
            const xDim = document.getElementById('x-dimension').value;
            const yDim = document.getElementById('y-dimension').value;
            
            if (!xDim || !yDim || xDim === yDim) {
                alert('Please select different dimensions for X and Y axes');
                return;
            }

            // Aggregate data by product (same logic as Python version)
            const productGroups = {};
            const identifierCol = processedData.identifierColumn;
            
            processedData.data.forEach(row => {
                const product = row[identifierCol];
                if (!product) return;
                
                const xVal = parseFloat(row[xDim]);
                const yVal = parseFloat(row[yDim]);
                
                if (isNaN(xVal) || isNaN(yVal)) return;
                
                if (!productGroups[product]) {
                    productGroups[product] = {
                        xValues: [],
                        yValues: [],
                        count: 0
                    };
                }
                
                productGroups[product].xValues.push(xVal);
                productGroups[product].yValues.push(yVal);
                productGroups[product].count++;
            });

            // Calculate averages for each product
            const plotData = [];
            Object.keys(productGroups).forEach(product => {
                const group = productGroups[product];
                const avgX = group.xValues.reduce((a, b) => a + b, 0) / group.xValues.length;
                const avgY = group.yValues.reduce((a, b) => a + b, 0) / group.yValues.length;
                
                plotData.push({
                    product: product,
                    x: avgX,
                    y: avgY,
                    frequency: group.count,
                    size: 100 + Math.min(700, group.count * 8) * 1.5 // 50% larger bubbles as requested
                });
            });

            // Create Plotly visualization
            createPlotlyMap(plotData, xDim, yDim);
            
            updateStepStatus('step2', 'completed');
            updateStepStatus('step3', 'active');
            document.getElementById('map-container').classList.remove('hidden');
        }

        function createPlotlyMap(plotData, xDim, yDim) {
            // Prepare data for Plotly
            const trace = {
                x: plotData.map(d => d.x),
                y: plotData.map(d => d.y),
                text: plotData.map(d => `${d.product}<br>Responses: ${d.frequency}`),
                mode: 'markers+text',
                marker: {
                    size: plotData.map(d => Math.sqrt(d.size) / 2), // Adjust size for Plotly
                    color: plotData.map((d, i) => {
                        // Color by brand (first word of product name)
                        const brand = d.product.split(/[\s-]/)[0];
                        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA726', '#AB47BC', '#66BB6A', '#EF5350', '#26A69A'];
                        return colors[brand.charCodeAt(0) % colors.length];
                    }),
                    opacity: 0.8,
                    line: {
                        color: 'black',
                        width: 1.5
                    }
                },
                textposition: 'middle left',
                textfont: {
                    size: 12,
                    family: 'Arial, sans-serif'
                },
                hovertemplate: '<b>%{text}</b><br>' +
                              xDim.replace(/_/g, ' ') + ': %{x:.1f}<br>' +
                              yDim.replace(/_/g, ' ') + ': %{y:.1f}<extra></extra>'
            };

            // Calculate auto-zoom range
            const xValues = plotData.map(d => d.x);
            const yValues = plotData.map(d => d.y);
            
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);
            
            const xRange = Math.max(xMax - xMin, 0.5);
            const yRange = Math.max(yMax - yMin, 0.5);
            
            const xPadding = xRange * 0.1;
            const yPadding = yRange * 0.1;

            // Calculate means for reference lines
            const xMean = xValues.reduce((a, b) => a + b, 0) / xValues.length;
            const yMean = yValues.reduce((a, b) => a + b, 0) / yValues.length;

            const layout = {
                title: {
                    text: `Perceptual Map: ${xDim.replace(/_/g, ' ')} vs ${yDim.replace(/_/g, ' ')}<br><sub>Bubble size = Survey response frequency</sub>`,
                    font: { size: 16 }
                },
                xaxis: {
                    title: xDim.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    range: [xMin - xPadding, xMax + xPadding],
                    showgrid: true,
                    gridwidth: 1,
                    gridcolor: 'rgba(128,128,128,0.3)'
                },
                yaxis: {
                    title: yDim.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    range: [yMin - yPadding, yMax + yPadding],
                    showgrid: true,
                    gridwidth: 1,
                    gridcolor: 'rgba(128,128,128,0.3)'
                },
                shapes: [
                    // Reference lines
                    {
                        type: 'line',
                        x0: xMean, y0: yMin - yPadding,
                        x1: xMean, y1: yMax + yPadding,
                        line: { color: 'gray', width: 1, dash: 'dash' }
                    },
                    {
                        type: 'line',
                        x0: xMin - xPadding, y0: yMean,
                        x1: xMax + xPadding, y1: yMean,
                        line: { color: 'gray', width: 1, dash: 'dash' }
                    }
                ],
                annotations: [
                    // Quadrant labels
                    {
                        x: xMax - xPadding/3, y: yMax - yPadding/3,
                        text: 'Leaders', showarrow: false,
                        bgcolor: 'lightgreen', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMin + xPadding/3, y: yMax - yPadding/3,
                        text: 'Niche Players', showarrow: false,
                        bgcolor: 'lightblue', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMin + xPadding/3, y: yMin + yPadding/3,
                        text: 'Challenged', showarrow: false,
                        bgcolor: 'lightcoral', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMax - xPadding/3, y: yMin + yPadding/3,
                        text: 'Specialists', showarrow: false,
                        bgcolor: 'lightyellow', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    }
                ],
                showlegend: false,
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };

            const config = {
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                responsive: true
            };

            Plotly.newPlot('plotly-div', [trace], layout, config);
        }

        function updateStepStatus(stepId, status) {
            const step = document.getElementById(stepId);
            const indicator = step.querySelector('.status-indicator');
            
            // Remove all status classes
            step.classList.remove('active', 'completed');
            indicator.classList.remove('status-pending', 'status-active', 'status-completed');
            
            // Add new status
            step.classList.add(status === 'active' ? 'active' : status);
            indicator.classList.add(`status-${status}`);
        }

        // Event listeners
        document.getElementById('generate-map-btn').addEventListener('click', generatePerceptualMap);

        // Initialize
        setupFileUpload();
    </script>
</body>
</html>