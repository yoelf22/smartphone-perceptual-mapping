<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perceptual Mapping Analysis Tool</title>
    <!-- GitHub Pages deployment -->
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VCVEW5VYX7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VCVEW5VYX7');
    </script>
    
    <!-- External libraries -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 30px; 
            border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.15); 
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.2em;
        }
        .step { 
            margin-bottom: 30px; 
            padding: 25px; 
            border: 2px solid #e8ecf0; 
            border-radius: 12px; 
            background: #fafbfc;
            transition: all 0.3s ease;
        }
        .step.active { 
            border-color: #4CAF50; 
            background: #f8fff8;
        }
        .step.completed { 
            border-color: #4CAF50; 
            background: #f0f8f0; 
        }
        .step-header { 
            font-size: 1.4em; 
            font-weight: 600; 
            margin-bottom: 15px; 
            color: #333; 
        }
        .file-drop { 
            border: 3px dashed #ddd; 
            border-radius: 12px; 
            padding: 40px 20px; 
            text-align: center; 
            color: #666; 
            margin: 15px 0;
            background: white;
            transition: all 0.3s ease;
        }
        .file-drop.dragover { 
            border-color: #4CAF50; 
            background: #f8fff8; 
            color: #4CAF50;
        }
        .file-drop:hover {
            border-color: #999;
            background: #f9f9f9;
        }
        textarea { 
            width: calc(100% - 32px); 
            min-height: 200px; 
            padding: 15px; 
            border: 2px solid #e8ecf0; 
            border-radius: 8px; 
            font-family: 'Monaco', 'Menlo', monospace; 
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            display: block;
            margin: 10px 0;
            background-color: white;
        }
        input[type="text"], select { 
            width: calc(100% - 22px); 
            padding: 12px 15px; 
            border: 2px solid #e8ecf0; 
            border-radius: 8px; 
            margin: 8px 0; 
            font-size: 16px;
        }
        button { 
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); 
            color: white; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 10px 5px 10px 0;
        }
        button:hover { 
            background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        button:disabled { 
            background: #e0e0e0; 
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pending { background-color: #ffc107; }
        .status-active { background-color: #2196f3; animation: pulse 2s infinite; }
        .status-completed { background-color: #4caf50; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }
        
        .analysis-summary { 
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); 
            padding: 20px; 
            border-radius: 12px; 
            margin: 15px 0;
            border-left: 5px solid #2196f3;
        }
        .hidden { display: none; }
        .data-preview {
            max-height: 300px;
            overflow: auto;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .dimensions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .map-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        #plotly-div {
            width: 100%;
            height: 600px;
        }
        .info-box {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #155724;
        }
        #qualitative-text {
            width: calc(100% - 32px) !important;
            min-height: 200px !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-sizing: border-box !important;
        }
        #text-word-counter {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
            font-weight: 500;
        }
        .keyword-list { 
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px; 
            margin: 15px 0; 
            max-width: 100%;
        }
        .keyword-tag { 
            background: #e3f2fd; 
            padding: 8px 15px; 
            border-radius: 20px; 
            font-size: 0.9em; 
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            white-space: nowrap;
            min-height: 32px;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Perceptual Mapping Analyzer</h1>
        <p class="subtitle">Upload survey data to generate interactive perceptual maps and competitive analysis</p>
        
        <!-- Step 1: Qualitative Research Input -->
        <div class="step active" id="step1">
            <div class="step-header">
                <span class="status-indicator status-active"></span>
                üìù Step 1: Qualitative Research Input (Optional)
            </div>
            <p><strong>Purpose:</strong> Generate research dimensions from qualitative data (interviews, surveys, etc.)</p>
            
            <div class="file-drop" id="text-drop">
                <div style="font-size: 48px; margin-bottom: 15px;">üìù</div>
                <p><strong>Drag & drop text files here</strong></p>
                <p style="margin: 10px 0;">or</p>
                <input type="file" id="text-file" accept=".txt" style="display: none;">
                <button onclick="document.getElementById('text-file').click()">Browse Text Files</button>
            </div>
            
            <div style="margin: 20px 0;">
                <h4 style="margin-bottom: 10px; color: #333;">üìù Paste Your Qualitative Text:</h4>
                <textarea id="qualitative-text" placeholder="Paste your qualitative research data here (interviews, discussions, survey responses, etc.)...

Examples:
‚Ä¢ Interview transcripts
‚Ä¢ User feedback
‚Ä¢ Product reviews  
‚Ä¢ Focus group notes
‚Ä¢ Market research text

Start typing or paste text here..."></textarea>
            </div>
            
            <div class="info-box">
                <strong>üí° Tip:</strong> This step helps identify key dimensions for your perceptual map. You can skip this and proceed directly to survey data upload.
            </div>
            
            <div id="text-word-counter" class="word-counter">0 words</div>
            
            <button id="process-text-btn" disabled>ü§ñ Process Text & Extract Dimensions</button>
            <button onclick="skipToSurveyData()" style="margin-left: 10px;">Skip to Survey Data ‚Üí</button>
            
            <div id="extracted-dimensions" class="analysis-summary hidden">
                <h4>üéØ Extracted Dimensions:</h4>
                <div id="dimensions-list"></div>
            </div>
        </div>

        <!-- Step 2: Survey Data Upload -->
        <div class="step" id="step2">
            <div class="step-header">
                <span class="status-indicator status-pending"></span>
                üìä Step 2: Survey Data Upload
            </div>
            <p><strong>Requirements:</strong> CSV file with survey responses (30+ respondents, rating scale 1-9)</p>
            
            <div class="file-drop" id="survey-drop">
                <div style="font-size: 48px; margin-bottom: 15px;">üìä</div>
                <p><strong>Drag & drop your CSV file here</strong></p>
                <p style="margin: 10px 0;">or</p>
                <input type="file" id="survey-file" accept=".csv" style="display: none;">
                <button onclick="document.getElementById('survey-file').click()">Browse CSV Files</button>
                <button onclick="loadSampleData()" style="margin-left: 10px; background: #2196F3;">Load Sample Data</button>
            </div>
            
            <div id="data-preview" class="data-preview hidden"></div>
            <div id="data-summary" class="analysis-summary hidden"></div>
        </div>
        
        <!-- Step 3: Map Configuration -->
        <div class="step" id="step3">
            <div class="step-header">
                <span class="status-indicator status-pending"></span>
                ‚öôÔ∏è Step 3: Configure Perceptual Map
            </div>
            
            <div class="dimensions-grid">
                <div>
                    <label for="x-dimension"><strong>X-Axis Dimension:</strong></label>
                    <select id="x-dimension">
                        <option value="">Select dimension...</option>
                    </select>
                </div>
                <div>
                    <label for="y-dimension"><strong>Y-Axis Dimension:</strong></label>
                    <select id="y-dimension">
                        <option value="">Select dimension...</option>
                    </select>
                </div>
            </div>
            
            <div class="info-box">
                <strong>üí° Tip:</strong> Choose dimensions that represent different competitive aspects (e.g., Price vs Quality, Innovation vs Reliability)
            </div>
            
            <button id="generate-map-btn" disabled>Generate Perceptual Map</button>
        </div>
        
        <!-- Step 4: Results -->
        <div class="step" id="step4">
            <div class="step-header">
                <span class="status-indicator status-pending"></span>
                üìà Step 4: Interactive Perceptual Map
            </div>
            
            <div id="map-container" class="map-container hidden">
                <div id="plotly-div"></div>
                <div class="info-box">
                    <strong>üéØ How to read this map:</strong>
                    <ul>
                        <li><strong>Position:</strong> Each product's average score on the selected dimensions</li>
                        <li><strong>Bubble size:</strong> Number of survey responses for that product</li>
                        <li><strong>Quadrants:</strong> Different competitive positions based on the chosen dimensions</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let surveyData = null;
        let processedData = null;

        // File upload handling
        function setupFileUpload() {
            const dropZone = document.getElementById('survey-drop');
            const fileInput = document.getElementById('survey-file');
            
            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        }

        function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            // Read file as text first to debug
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                console.log('Raw CSV content (first 500 chars):', csvText.substring(0, 500));
                
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    trimHeaders: true,
                    dynamicTyping: false,  // Keep as strings initially to avoid conversion issues
                    complete: function(results) {
                        console.log('Papa Parse results:', results);
                        
                        if (results.errors.length > 0) {
                            console.log('CSV parsing errors:', results.errors);
                            // Show all errors for debugging
                            alert('CSV parsing errors found:\n' + results.errors.map(err => `Row ${err.row}: ${err.message}`).join('\n'));
                            return;
                        }
                        
                        if (!results.data || results.data.length === 0) {
                            alert('No data found in CSV file.');
                            return;
                        }
                        
                        // More robust data filtering
                        surveyData = results.data.filter(row => {
                            const values = Object.values(row);
                            const hasData = values.some(val => val !== null && val !== undefined && val.toString().trim() !== '');
                            console.log('Row data:', row, 'Has data:', hasData);
                            return hasData;
                        });
                        
                        console.log('Filtered survey data:', surveyData);
                        
                        if (surveyData.length === 0) {
                            alert('No valid data rows found in CSV file. Please check the format.');
                            return;
                        }
                        
                        displayDataPreview();
                        analyzeData();
                        updateStepStatus('step2', 'completed');
                        updateStepStatus('step3', 'active');
                    }
                });
            };
            reader.readAsText(file);
        }

        function displayDataPreview() {
            const preview = document.getElementById('data-preview');
            const sample = surveyData.slice(0, 5);
            
            let html = '<h4>Data Preview (first 5 rows):</h4><table border="1" style="width: 100%; font-size: 11px;">';
            
            // Header
            html += '<tr>';
            Object.keys(sample[0]).forEach(key => {
                html += `<th style="padding: 5px; background: #f0f0f0;">${key}</th>`;
            });
            html += '</tr>';
            
            // Data rows
            sample.forEach(row => {
                html += '<tr>';
                Object.values(row).forEach(val => {
                    html += `<td style="padding: 5px;">${val}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</table>';
            preview.innerHTML = html;
            preview.classList.remove('hidden');
        }

        // Global variable to store extracted dimensions
        let extractedQualitativeDimensions = [];

        function analyzeData() {
            if (!surveyData || surveyData.length === 0) return;

            // Check for dimension mismatch between qualitative and quantitative data
            checkDimensionAlignment();

            // Find identifier column (product names)
            const columns = Object.keys(surveyData[0]);
            let identifierColumn = null;
            
            // Look for columns that might contain product names
            const identifierKeywords = ['phone', 'product', 'brand', 'model', 'device', 'name', 'item'];
            for (const col of columns) {
                if (identifierKeywords.some(keyword => col.toLowerCase().includes(keyword))) {
                    identifierColumn = col;
                    break;
                }
            }
            
            if (!identifierColumn) {
                identifierColumn = columns[0]; // Use first column as fallback
            }

            // Find rating columns (numeric columns that aren't the identifier)
            const ratingColumns = columns.filter(col => {
                if (col === identifierColumn) return false;
                
                // Check if column contains numeric data
                const sampleValues = surveyData.slice(0, 10).map(row => row[col]);
                const numericValues = sampleValues.filter(val => !isNaN(parseFloat(val)) && isFinite(val));
                return numericValues.length > sampleValues.length * 0.7; // At least 70% numeric
            });

            processedData = {
                identifierColumn: identifierColumn,
                ratingColumns: ratingColumns,
                data: surveyData
            };

            // Populate dimension selectors
            const xSelect = document.getElementById('x-dimension');
            const ySelect = document.getElementById('y-dimension');
            
            xSelect.innerHTML = '<option value="">Select dimension...</option>';
            ySelect.innerHTML = '<option value="">Select dimension...</option>';
            
            ratingColumns.forEach(col => {
                const option1 = new Option(col.replace(/_/g, ' '), col);
                const option2 = new Option(col.replace(/_/g, ' '), col);
                xSelect.appendChild(option1);
                ySelect.appendChild(option2);
            });

            // Display analysis summary
            const summary = document.getElementById('data-summary');
            summary.innerHTML = `
                <h4>üìä Data Analysis Summary:</h4>
                <p><strong>Total Responses:</strong> ${surveyData.length.toLocaleString()}</p>
                <p><strong>Product Column:</strong> ${identifierColumn}</p>
                <p><strong>Rating Dimensions:</strong> ${ratingColumns.length} (${ratingColumns.join(', ')})</p>
                <p><strong>Unique Products:</strong> ${[...new Set(surveyData.map(row => row[identifierColumn]))].length}</p>
            `;
            summary.classList.remove('hidden');

            // Enable map generation when both dimensions are selected
            function checkDimensions() {
                const xDim = document.getElementById('x-dimension').value;
                const yDim = document.getElementById('y-dimension').value;
                document.getElementById('generate-map-btn').disabled = !xDim || !yDim || xDim === yDim;
            }

            document.getElementById('x-dimension').addEventListener('change', checkDimensions);
            document.getElementById('y-dimension').addEventListener('change', checkDimensions);
        }

        function generatePerceptualMap() {
            const xDim = document.getElementById('x-dimension').value;
            const yDim = document.getElementById('y-dimension').value;
            
            if (!xDim || !yDim || xDim === yDim) {
                alert('Please select different dimensions for X and Y axes');
                return;
            }

            // Aggregate data by product (same logic as Python version)
            const productGroups = {};
            const identifierCol = processedData.identifierColumn;
            
            processedData.data.forEach(row => {
                const product = row[identifierCol];
                if (!product) return;
                
                const xVal = parseFloat(row[xDim]);
                const yVal = parseFloat(row[yDim]);
                
                if (isNaN(xVal) || isNaN(yVal)) return;
                
                if (!productGroups[product]) {
                    productGroups[product] = {
                        xValues: [],
                        yValues: [],
                        count: 0
                    };
                }
                
                productGroups[product].xValues.push(xVal);
                productGroups[product].yValues.push(yVal);
                productGroups[product].count++;
            });

            // Calculate averages for each product
            const plotData = [];
            Object.keys(productGroups).forEach(product => {
                const group = productGroups[product];
                const avgX = group.xValues.reduce((a, b) => a + b, 0) / group.xValues.length;
                const avgY = group.yValues.reduce((a, b) => a + b, 0) / group.yValues.length;
                
                plotData.push({
                    product: product,
                    x: avgX,
                    y: avgY,
                    frequency: group.count,
                    size: 100 + Math.min(700, group.count * 8) * 1.95 // 50% + 30% = 95% larger bubbles
                });
            });

            // Create Plotly visualization
            createPlotlyMap(plotData, xDim, yDim);
            
            updateStepStatus('step3', 'completed');
            updateStepStatus('step4', 'active');
            document.getElementById('map-container').classList.remove('hidden');
        }

        function createPlotlyMap(plotData, xDim, yDim) {
            // Prepare data for Plotly - markers only (no text)
            const trace = {
                x: plotData.map(d => d.x),
                y: plotData.map(d => d.y),
                text: plotData.map(d => `${d.product}<br>Responses: ${d.frequency}`),
                mode: 'markers', // Remove text mode - we'll use annotations instead
                marker: {
                    size: plotData.map(d => Math.sqrt(d.size) / 2 * 1.3), // 30% larger bubbles for Plotly
                    color: plotData.map((d, i) => {
                        // Color by brand (first word of product name)
                        const brand = d.product.split(/[\s-]/)[0];
                        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA726', '#AB47BC', '#66BB6A', '#EF5350', '#26A69A'];
                        return colors[brand.charCodeAt(0) % colors.length];
                    }),
                    opacity: 0.8,
                    line: {
                        color: 'black',
                        width: 1.5
                    }
                },
                hovertemplate: '<b>%{text}</b><br>' +
                              xDim.replace(/_/g, ' ') + ': %{x:.1f}<br>' +
                              yDim.replace(/_/g, ' ') + ': %{y:.1f}<extra></extra>'
            };

            // Create custom annotations for labels with leader lines
            const labelAnnotations = plotData.map((d, i) => {
                const brand = d.product.split(/[\s-]/)[0];
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA726', '#AB47BC', '#66BB6A', '#EF5350', '#26A69A'];
                const bubbleColor = colors[brand.charCodeAt(0) % colors.length];
                
                // Calculate bubble radius in data units (approximate)
                const bubbleRadius = Math.sqrt(d.size) / 2 * 1.3;
                const radiusInDataUnits = bubbleRadius * 0.01; // Rough conversion
                
                // Position label to the left at reduced distance (half of previous)
                const labelOffset = radiusInDataUnits + 0.15; // Reduced from 0.3 to 0.15
                const labelX = d.x - labelOffset;
                
                // Convert hex color to rgba for transparency
                function hexToRgba(hex, alpha) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                
                const borderColor = hexToRgba(bubbleColor, 0.9); // Same color as bubble, 90% opacity
                
                return {
                    x: labelX,
                    y: d.y,
                    text: d.product,
                    showarrow: true,
                    arrowhead: 2, // More visible arrowhead
                    arrowsize: 1,
                    arrowwidth: 2,
                    arrowcolor: bubbleColor,
                    standoff: 4, // Distance from text to start of arrow
                    startstandoff: 4, // Distance from point to end of arrow
                    ax: d.x, // Point to the center of the circle
                    ay: d.y,
                    axref: 'x',
                    ayref: 'y',
                    font: {
                        size: 11,
                        color: 'white',
                        family: 'Arial, sans-serif'
                    },
                    bgcolor: bubbleColor,
                    opacity: 0.9,
                    bordercolor: borderColor, // Same color as bubble with transparency
                    borderwidth: 2,
                    borderpad: 6,
                    xanchor: 'right',
                    yanchor: 'middle'
                };
            });

            // Calculate auto-zoom range
            const xValues = plotData.map(d => d.x);
            const yValues = plotData.map(d => d.y);
            
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);
            
            const xRange = Math.max(xMax - xMin, 0.5);
            const yRange = Math.max(yMax - yMin, 0.5);
            
            const xPadding = xRange * 0.1;
            const yPadding = yRange * 0.1;

            // Calculate means for reference lines
            const xMean = xValues.reduce((a, b) => a + b, 0) / xValues.length;
            const yMean = yValues.reduce((a, b) => a + b, 0) / yValues.length;

            const layout = {
                title: {
                    text: `Perceptual Map: ${xDim.replace(/_/g, ' ')} vs ${yDim.replace(/_/g, ' ')}<br><sub>Bubble size = Survey response frequency</sub>`,
                    font: { size: 16 }
                },
                xaxis: {
                    title: xDim.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    range: [xMin - xPadding, xMax + xPadding],
                    showgrid: true,
                    gridwidth: 1,
                    gridcolor: 'rgba(128,128,128,0.3)'
                },
                yaxis: {
                    title: yDim.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    range: [yMin - yPadding, yMax + yPadding],
                    showgrid: true,
                    gridwidth: 1,
                    gridcolor: 'rgba(128,128,128,0.3)'
                },
                shapes: [
                    // Reference lines
                    {
                        type: 'line',
                        x0: xMean, y0: yMin - yPadding,
                        x1: xMean, y1: yMax + yPadding,
                        line: { color: 'gray', width: 1, dash: 'dash' }
                    },
                    {
                        type: 'line',
                        x0: xMin - xPadding, y0: yMean,
                        x1: xMax + xPadding, y1: yMean,
                        line: { color: 'gray', width: 1, dash: 'dash' }
                    }
                ],
                annotations: [
                    // Quadrant labels
                    {
                        x: xMax - xPadding/3, y: yMax - yPadding/3,
                        text: 'Leaders', showarrow: false,
                        bgcolor: 'lightgreen', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMin + xPadding/3, y: yMax - yPadding/3,
                        text: 'Niche Players', showarrow: false,
                        bgcolor: 'lightblue', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMin + xPadding/3, y: yMin + yPadding/3,
                        text: 'Challenged', showarrow: false,
                        bgcolor: 'lightcoral', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    },
                    {
                        x: xMax - xPadding/3, y: yMin + yPadding/3,
                        text: 'Specialists', showarrow: false,
                        bgcolor: 'lightyellow', opacity: 0.8,
                        bordercolor: 'black', borderwidth: 1
                    }
                ].concat(labelAnnotations), // Add product labels with leader lines
                showlegend: false,
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };

            const config = {
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                responsive: true
            };

            Plotly.newPlot('plotly-div', [trace], layout, config);
        }

        function updateStepStatus(stepId, status) {
            const step = document.getElementById(stepId);
            const indicator = step.querySelector('.status-indicator');
            
            // Remove all status classes
            step.classList.remove('active', 'completed');
            indicator.classList.remove('status-pending', 'status-active', 'status-completed');
            
            // Add new status
            step.classList.add(status === 'active' ? 'active' : status);
            indicator.classList.add(`status-${status}`);
        }

        // Load sample data function with frequency data for realistic bubble sizing
        function loadSampleData() {
            const sampleData = [
                // iPhone 15 Pro - High popularity (85 responses)
                ...Array.from({length: 85}, (_, i) => ({
                    phone_model: 'iPhone 15 Pro',
                    design: (8.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (6.2 + (Math.random() - 0.5) * 1.2).toFixed(1),
                    camera_quality: (9.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    performance: (9.2 + (Math.random() - 0.5) * 0.6).toFixed(1),
                    build_quality: (8.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.7 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // Samsung Galaxy S24 Ultra - High popularity (72 responses)
                ...Array.from({length: 72}, (_, i) => ({
                    phone_model: 'Samsung Galaxy S24 Ultra',
                    design: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    price_value: (6.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    camera_quality: (9.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (8.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.7 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.6 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // Samsung Galaxy A54 - Medium popularity (65 responses)
                ...Array.from({length: 65}, (_, i) => ({
                    phone_model: 'Samsung Galaxy A54',
                    design: (7.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    battery_life: (8.5 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (7.6 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    build_quality: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    user_interface: (7.7 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    innovation: (7.2 + (Math.random() - 0.5) * 1.0).toFixed(1)
                })),
                
                // iPhone 15 - Medium popularity (58 responses)
                ...Array.from({length: 58}, (_, i) => ({
                    phone_model: 'iPhone 15',
                    design: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    price_value: (6.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    camera_quality: (8.7 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (7.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    performance: (8.8 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.6 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.5 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // Samsung Galaxy S24 - Medium popularity (52 responses)
                ...Array.from({length: 52}, (_, i) => ({
                    phone_model: 'Samsung Galaxy S24',
                    design: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    price_value: (7.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (8.5 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.3 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // Google Pixel 8 Pro - Lower popularity (45 responses)
                ...Array.from({length: 45}, (_, i) => ({
                    phone_model: 'Google Pixel 8 Pro',
                    design: (7.9 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (7.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (8.8 + (Math.random() - 0.5) * 0.6).toFixed(1),
                    battery_life: (7.4 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    performance: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.7 + (Math.random() - 0.5) * 0.6).toFixed(1)
                })),
                
                // Google Pixel 8 - Lower popularity (38 responses)
                ...Array.from({length: 38}, (_, i) => ({
                    phone_model: 'Google Pixel 8',
                    design: (7.6 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (7.8 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (8.5 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (7.2 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    performance: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // OnePlus 12 - Lower popularity (35 responses)
                ...Array.from({length: 35}, (_, i) => ({
                    phone_model: 'OnePlus 12',
                    design: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    price_value: (7.6 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (8.3 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (8.7 + (Math.random() - 0.5) * 0.6).toFixed(1),
                    build_quality: (8.4 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // Xiaomi 14 Pro - Lower popularity (32 responses)  
                ...Array.from({length: 32}, (_, i) => ({
                    phone_model: 'Xiaomi 14 Pro',
                    design: (7.7 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (8.5 + (Math.random() - 0.5) * 0.6).toFixed(1),
                    camera_quality: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (8.2 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (7.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    innovation: (8.3 + (Math.random() - 0.5) * 0.8).toFixed(1)
                })),
                
                // OnePlus 11 - Low popularity (28 responses)
                ...Array.from({length: 28}, (_, i) => ({
                    phone_model: 'OnePlus 11',
                    design: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    battery_life: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (8.3 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    build_quality: (8.1 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    user_interface: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    innovation: (7.8 + (Math.random() - 0.5) * 1.0).toFixed(1)
                })),
                
                // Nothing Phone 2 - Low popularity (25 responses)
                ...Array.from({length: 25}, (_, i) => ({
                    phone_model: 'Nothing Phone 2',
                    design: (7.4 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    price_value: (7.3 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    camera_quality: (7.6 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    battery_life: (7.9 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    performance: (7.5 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    build_quality: (7.6 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    user_interface: (8.0 + (Math.random() - 0.5) * 0.8).toFixed(1),
                    innovation: (8.9 + (Math.random() - 0.5) * 0.4).toFixed(1)
                })),
                
                // Xiaomi Redmi Note 13 - Low popularity (22 responses)
                ...Array.from({length: 22}, (_, i) => ({
                    phone_model: 'Xiaomi Redmi Note 13',
                    design: (6.9 + (Math.random() - 0.5) * 1.2).toFixed(1),
                    price_value: (8.8 + (Math.random() - 0.5) * 0.4).toFixed(1),
                    camera_quality: (7.2 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    battery_life: (8.7 + (Math.random() - 0.5) * 0.6).toFixed(1),
                    performance: (7.1 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    build_quality: (7.2 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    user_interface: (7.1 + (Math.random() - 0.5) * 1.0).toFixed(1),
                    innovation: (7.0 + (Math.random() - 0.5) * 1.0).toFixed(1)
                }))
            ];

            // Shuffle the data to make it more realistic
            const shuffledData = sampleData.sort(() => Math.random() - 0.5);
            
            surveyData = shuffledData;
            
            console.log('Generated sample data with', surveyData.length, 'total responses');
            console.log('Products and response counts:');
            const productCounts = {};
            surveyData.forEach(row => {
                productCounts[row.phone_model] = (productCounts[row.phone_model] || 0) + 1;
            });
            console.log(productCounts);
            
            displayDataPreview();
            analyzeData();
            updateStepStatus('step2', 'completed');
            updateStepStatus('step3', 'active');
        }

        // Event listeners
        document.getElementById('generate-map-btn').addEventListener('click', generatePerceptualMap);

        // Skip to survey data function
        function skipToSurveyData() {
            updateStepStatus('step1', 'completed');
            updateStepStatus('step2', 'active');
        }

        // Text file handling
        function setupTextFileUpload() {
            const dropZone = document.getElementById('text-drop');
            const fileInput = document.getElementById('text-file');
            
            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleTextFileUpload(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleTextFileUpload(e.target.files[0]);
                }
            });
        }

        function handleTextFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.txt')) {
                alert('Please upload a text file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const textarea = document.getElementById('qualitative-text');
                const wordCounter = document.getElementById('text-word-counter');
                const processBtn = document.getElementById('process-text-btn');
                
                textarea.value = e.target.result;
                
                // Manually update word counter and button state
                const text = e.target.result;
                const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
                
                if (wordCounter) {
                    wordCounter.textContent = wordCount.toLocaleString() + ' words';
                }
                
                if (processBtn) {
                    processBtn.disabled = wordCount < 50;
                    
                    if (wordCount < 50) {
                        processBtn.textContent = 'ü§ñ Process Text & Extract Dimensions (min 50 words)';
                    } else {
                        processBtn.textContent = 'ü§ñ Process Text & Extract Dimensions';
                    }
                }
                
                alert(`Text file loaded with ${wordCount.toLocaleString()} words! You can now review and edit the content, then process dimensions.`);
            };
            reader.readAsText(file);
        }

        // Event listeners will be set up in DOMContentLoaded

        // Client-side dimension extraction function
        function extractDimensionsFromText(text) {
            const lowerText = text.toLowerCase();
            
            // Common perceptual mapping dimensions with their keywords
            const dimensionKeywords = {
                'Design_Quality': ['design', 'appearance', 'look', 'aesthetic', 'visual', 'beautiful', 'attractive', 'style', 'elegant', 'sleek'],
                'Price_Value': ['price', 'cost', 'value', 'money', 'expensive', 'cheap', 'affordable', 'budget', 'worth', 'pricing'],
                'Performance': ['fast', 'slow', 'speed', 'performance', 'quick', 'responsive', 'lag', 'smooth', 'powerful', 'efficient'],
                'Quality': ['quality', 'build', 'durable', 'solid', 'reliable', 'sturdy', 'robust', 'premium', 'cheap', 'flimsy'],
                'Innovation': ['innovative', 'new', 'advanced', 'cutting-edge', 'modern', 'technology', 'features', 'unique', 'revolutionary'],
                'User_Experience': ['easy', 'difficult', 'user-friendly', 'intuitive', 'complex', 'simple', 'usable', 'experience', 'interface'],
                'Brand_Trust': ['trust', 'brand', 'reputation', 'reliable', 'credible', 'established', 'known', 'famous', 'popular'],
                'Customer_Service': ['service', 'support', 'help', 'assistance', 'customer', 'staff', 'helpful', 'responsive', 'care'],
                'Durability': ['durable', 'last', 'lasting', 'strong', 'break', 'fragile', 'sturdy', 'robust', 'long-term'],
                'Convenience': ['convenient', 'easy', 'accessible', 'simple', 'hassle', 'effort', 'quick', 'straightforward']
            };
            
            // Count keyword occurrences for each dimension
            const dimensionScores = {};
            Object.keys(dimensionKeywords).forEach(dimension => {
                let score = 0;
                dimensionKeywords[dimension].forEach(keyword => {
                    const regex = new RegExp('\\b' + keyword + '\\w*\\b', 'gi');
                    const matches = lowerText.match(regex);
                    if (matches) {
                        score += matches.length;
                    }
                });
                dimensionScores[dimension] = score;
            });
            
            // Sort dimensions by relevance (score)
            const extractedDimensions = Object.entries(dimensionScores)
                .filter(([dim, score]) => score > 0)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8) // Top 8 dimensions
                .map(([dim, score]) => ({
                    name: dim,
                    score: score,
                    displayName: dim.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
                }));
            
            // Display extracted dimensions
            displayExtractedDimensions(extractedDimensions);
            
            // Reset the process button
            const processBtn = document.getElementById('process-text-btn');
            processBtn.textContent = '‚úÖ Dimensions Extracted';
            processBtn.disabled = false;
            
            // Update step status
            updateStepStatus('step1', 'completed');
            updateStepStatus('step2', 'active');
        }

        // Display extracted dimensions
        function displayExtractedDimensions(dimensions) {
            const dimensionsDiv = document.getElementById('dimensions-list');
            const extractedDiv = document.getElementById('extracted-dimensions');
            
            // Store dimensions globally for comparison
            extractedQualitativeDimensions = dimensions;
            
            if (dimensions.length === 0) {
                dimensionsDiv.innerHTML = '<p class="warning-box">No clear dimensions found in the text. Consider adding more descriptive content or skip to manual survey data upload.</p>';
            } else {
                let html = '<p><strong>Found ' + dimensions.length + ' relevant dimensions:</strong></p>';
                html += '<div class="keyword-list">';
                dimensions.forEach(dim => {
                    html += `<span class="keyword-tag" style="position: relative;">
                        ${dim.displayName}
                        <small style="position: absolute; top: -8px; right: -8px; background: #ff6b6b; color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 10px; display: flex; align-items: center; justify-content: center;">${dim.score}</small>
                    </span>`;
                });
                html += '</div>';
                html += '<p style="margin-top: 15px;"><strong>üí° Next:</strong> Use these dimensions as column names in your CSV survey data, or upload survey data with different dimensions.</p>';
                dimensionsDiv.innerHTML = html;
            }
            
            extractedDiv.classList.remove('hidden');
        }

        // Check alignment between qualitative dimensions and CSV columns
        function checkDimensionAlignment() {
            if (!extractedQualitativeDimensions.length || !surveyData.length) {
                return; // No qualitative dimensions to compare
            }

            const columns = Object.keys(surveyData[0]);
            const identifierKeywords = ['phone', 'product', 'brand', 'model', 'device', 'name', 'item', 'respondent', 'id'];
            
            // Get non-identifier columns (potential rating dimensions)
            const csvDimensions = columns.filter(col => {
                return !identifierKeywords.some(keyword => col.toLowerCase().includes(keyword));
            });

            // Compare qualitative dimensions with CSV dimensions
            const qualitativeDimNames = extractedQualitativeDimensions.map(d => d.name.toLowerCase());
            const csvDimNames = csvDimensions.map(d => d.toLowerCase().replace(/_/g, ' '));
            
            const matches = [];
            const csvOnlyDims = [];
            const qualitativeOnlyDims = [];

            // Find matches and differences
            csvDimensions.forEach(csvDim => {
                const csvDimClean = csvDim.toLowerCase().replace(/_/g, ' ');
                const hasMatch = qualitativeDimNames.some(qualDim => {
                    return qualDim.replace(/_/g, ' ') === csvDimClean || 
                           qualDim.replace(/_/g, ' ').includes(csvDimClean.split(' ')[0]) ||
                           csvDimClean.includes(qualDim.replace(/_/g, ' ').split(' ')[0]);
                });
                
                if (hasMatch) {
                    matches.push(csvDim);
                } else {
                    csvOnlyDims.push(csvDim);
                }
            });

            extractedQualitativeDimensions.forEach(qualDim => {
                const qualDimClean = qualDim.name.toLowerCase().replace(/_/g, ' ');
                const hasMatch = csvDimNames.some(csvDim => {
                    return csvDim === qualDimClean || 
                           csvDim.includes(qualDimClean.split(' ')[0]) ||
                           qualDimClean.includes(csvDim.split(' ')[0]);
                });
                
                if (!hasMatch) {
                    qualitativeOnlyDims.push(qualDim.displayName);
                }
            });

            // Display alignment results
            showDimensionAlignmentResults(matches, csvOnlyDims, qualitativeOnlyDims);
        }

        // Show dimension alignment notification
        function showDimensionAlignmentResults(matches, csvOnly, qualitativeOnly) {
            const summaryDiv = document.getElementById('data-summary');
            
            let alignmentHtml = '<div style="margin-top: 20px; padding: 15px; border-left: 4px solid #2196F3; background: #e3f2fd;">';
            alignmentHtml += '<h4 style="margin: 0 0 10px 0; color: #1976D2;">üìä Dimension Alignment Analysis</h4>';
            
            if (matches.length > 0) {
                alignmentHtml += `<p><strong>‚úÖ Matching dimensions (${matches.length}):</strong> ${matches.join(', ')}</p>`;
            }
            
            if (csvOnly.length > 0) {
                alignmentHtml += `<p><strong>üìà Additional CSV dimensions (${csvOnly.length}):</strong> ${csvOnly.join(', ')}</p>`;
                alignmentHtml += '<p style="font-size: 0.9em; color: #666;"><em>These dimensions from your CSV data will be available for mapping.</em></p>';
            }
            
            if (qualitativeOnly.length > 0) {
                alignmentHtml += `<p><strong>üìù Qualitative-only dimensions (${qualitativeOnly.length}):</strong> ${qualitativeOnly.join(', ')}</p>`;
                alignmentHtml += '<p style="font-size: 0.9em; color: #666;"><em>These dimensions were identified in your text but not found in the CSV data.</em></p>';
            }
            
            alignmentHtml += '<p style="margin-top: 10px;"><strong>üí° Result:</strong> Using CSV dimensions for perceptual mapping. You can create maps with any of the available CSV dimensions above.</p>';
            alignmentHtml += '</div>';
            
            // Insert alignment info into the existing summary
            const currentContent = summaryDiv.innerHTML;
            summaryDiv.innerHTML = currentContent + alignmentHtml;
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            // Check if elements exist
            const textArea = document.getElementById('qualitative-text');
            const wordCounter = document.getElementById('text-word-counter');
            const processBtn = document.getElementById('process-text-btn');
            
            console.log('Elements found:', {
                textArea: !!textArea,
                wordCounter: !!wordCounter,
                processBtn: !!processBtn
            });
            
            setupFileUpload();
            setupTextFileUpload();
            
            // Force trigger the textarea event listener setup
            if (textArea) {
                console.log('Setting up textarea event listener...');
                textArea.addEventListener('input', function() {
                    const text = this.value;
                    const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
                    
                    console.log('Text changed, word count:', wordCount);
                    
                    // Update counter
                    if (wordCounter) {
                        wordCounter.textContent = wordCount.toLocaleString() + ' words';
                    }
                    
                    // Enable/disable process button based on word count
                    if (processBtn) {
                        processBtn.disabled = wordCount < 50;
                        
                        if (wordCount < 50) {
                            processBtn.textContent = 'ü§ñ Process Text & Extract Dimensions (min 50 words)';
                        } else {
                            processBtn.textContent = 'ü§ñ Process Text & Extract Dimensions';
                        }
                    }
                });
            }
            
            // Force trigger the process button event listener
            if (processBtn) {
                processBtn.addEventListener('click', function() {
                    const text = document.getElementById('qualitative-text').value;
                    if (!text || text.trim().split(/\s+/).length < 50) {
                        alert('Please enter at least 50 words of qualitative text.');
                        return;
                    }
                    
                    this.textContent = 'üîÑ Processing...';
                    this.disabled = true;
                    
                    extractDimensionsFromText(text);
                });
            }
        });
    </script>
</body>
</html>